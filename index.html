<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Fonserbc</title>

<script type="text/javascript" src="gl-matrix-min.js"></script>
<script type="text/javascript" src="AssetManager.js"></script>
<script type="text/javascript" src="Cube.js"></script>

<!-- Vertex shader -->
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec2 aTexCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    vec3 lightDir = vec3(0.0,0.0,1.0);

    varying float vlightApport;
    varying vec2 vTexCoord;

    void main(void) {
        vec4 mvPosition = uMVMatrix * vec4(aPosition, 1.0);

        vec3 transformedNormal = uNMatrix * normalize(aNormal);
        vlightApport = max(dot(transformedNormal, lightDir), 0.0);

        gl_Position = uPMatrix * mvPosition;
			
		vTexCoord = aTexCoord;
    }
</script>

<!-- Fragment shader -->
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying float vlightApport;
	varying vec2 vTexCoord;

	uniform sampler2D sampler;
	
    void main(void) {
        //gl_FragColor = vec4(texture2D(sampler, vTexCoord).rgb * vlightApport, 1.0);
		gl_FragColor = texture2D(sampler, vTexCoord);
    }
</script>


<!-- AnimatedHeader -->
<script type="text/javascript">
	/*********GOOGLE CODE*********/
	/**
	 * Provides requestAnimationFrame in a cross browser way.
	 */
	window.requestAnimFrame = (function() {
	  return window.requestAnimationFrame ||
			 window.webkitRequestAnimationFrame ||
			 window.mozRequestAnimationFrame ||
			 window.oRequestAnimationFrame ||
			 window.msRequestAnimationFrame ||
			 function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
			   window.setTimeout(callback, 1000/60);
			 };
	})();
	/*********GOOGLE CODE*********/
	
	function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }
	
	function max (x, y) {
		if (x > y) return x;
		return y;
	}
	
	function min (x, y) {
		if (x < y) return x;
		return y;
	}
	
	function abs (x) {
		if (x < 0) return -x;
		return x;
	}
	
	function loadTexture(gl, textureAsset) {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureAsset); // Security exception (?)
		
		return texture;
    }
	
	function Timer() {
		this.gameTime = 0;
		this.maxStep = 0.05;
		this.wallLastTimestamp = 0;
	}

	Timer.prototype.tick = function() {
		var wallCurrent = Date.now();
		var wallDelta = (wallCurrent - this.wallLastTimestamp) / 1000;
		this.wallLastTimestamp = wallCurrent;

		var gameDelta = Math.min(wallDelta, this.maxStep);
		this.gameTime += gameDelta;
		return gameDelta;
	}

    function AnimatedHeader(canvas) {
		this.gl = this.initWebGL(canvas);
		this.shaderProgram = this.initShaders("shader-vs","shader-fs");
		
		//ModelView Matrix & stack
		this.mvMatrix = mat4.create();
		this.mvMatrixStack = [];
		this.drawColor = vec3.fromValues(0.0,0.0,0.0);

		//Projection Matrix, ZNEAR = 3, ZFAR = 17, FOVY = 45
		this.pMatrix = mat4.create();
		mat4.perspective(this.pMatrix,45, this.gl.viewportWidth / this.gl.viewportHeight, 3, 17);

		this.timer = new Timer();

		//cube
		this.cube = new Cube(this.gl, "fon.png");
		this.rot = 0.0;
		this.rotSpeed = 100.0;

		this.gl.enable(this.gl.DEPTH_TEST);
		this.gl.clearColor(210.0/255.0,250.0/255.0,250.0/255.0, 1.0);
		
		//input
		this.mouseDown = false;
		this.mouseX = 0;
		this.mouseY = 0;
		this.newMouseX = 0;
		this.newMouseY = 0;	
		var AnimatedHeader = this;
        canvas.onmousedown = function(event) { AnimatedHeader.handleMouseDown(event); };
        document.onmouseup = function(event) { AnimatedHeader.handleMouseUp(event); };
        document.onmousemove = function(event) { AnimatedHeader.handleMouseMove(event); };
    }

    AnimatedHeader.prototype.handleMouseDown = function(event) {
        this.mouseDown = true;
    }

    AnimatedHeader.prototype.handleMouseUp = function(event) {
        this.mouseDown = false;
    }

    AnimatedHeader.prototype.handleMouseMove = function(event) {
        this.newMouseX = event.clientX;
        this.newMouseY = event.clientY;
    }

    AnimatedHeader.prototype.handleMouse = function(deltaTime) {
		var deltaX = this.newMouseX -this.mouseX;
		var deltaY = this.newMouseY -this.mouseY;

		deltaX *= 2.5;
		if(this.mouseDown == true) {
			if (this.rotSpeed < 0 && deltaX < 0)
				this.rotSpeed = min(this.rotSpeed, deltaX);
			else if (this.rotSpeed > 0 && deltaX > 0)
				this.rotSpeed = max(this.rotSpeed, deltaX);
			else this.rotSpeed = deltaX;
		}
		this.mouseX = this.newMouseX;
		this.mouseY = this.newMouseY;
    }

    AnimatedHeader.prototype.initWebGL = function(canvas) {
        try {
            var gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {}
        if (!gl) {
            alert("Could not init WebGL");
        }
		return gl;
    }

    AnimatedHeader.prototype.getShader = function(id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) { //text type
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = this.gl.createShader(this.gl.VERTEX_SHADER);
        } else {
            return null;
        }

        this.gl.shaderSource(shader, str);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) { //Compiling error
            alert(this.gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    AnimatedHeader.prototype.initShaders = function(stringV,stringF) { //retorna un programa a partir de dos shaders
        var vertexShader = this.getShader(stringV);
        var fragmentShader = this.getShader(stringF);

        var program = this.gl.createProgram();
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        this.gl.linkProgram(program);

        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            alert("No s'han pogut inicialitzar els shaders");
        }

        this.gl.useProgram(program);

		//Attributes and Uniforms
        program.vertexPositionAttribute = this.gl.getAttribLocation(program, "aPosition");
        this.gl.enableVertexAttribArray(program.vertexPositionAttribute);

        program.vertexNormalAttribute = this.gl.getAttribLocation(program, "aNormal");
        this.gl.enableVertexAttribArray(program.vertexNormalAttribute);
		
		program.textureCoordAttribute = this.gl.getAttribLocation(program, "aTexCoord");
        this.gl.enableVertexAttribArray(program.textureCoordAttribute);

        program.pMatrixUniform = this.gl.getUniformLocation(program, "uPMatrix");
        program.mvMatrixUniform = this.gl.getUniformLocation(program, "uMVMatrix");
        program.nMatrixUniform = this.gl.getUniformLocation(program, "uNMatrix");
        program.colorUniform = this.gl.getUniformLocation(program, "uColor")
        program.samplerUniform = this.gl.getUniformLocation(program, "sampler");


		return program;
    }

    AnimatedHeader.prototype.mvPushMatrix = function() {
        var c = mat4.create();
        mat4.copy(c,this.mvMatrix);
        this.mvMatrixStack.push(c);
    }

    AnimatedHeader.prototype.mvPopMatrix = function() {
        if (this.mvMatrixStack.length == 0) {
            throw "PopMatrix no ha trobat cap matriu desada!"; 
        }
        this.mvMatrix = this.mvMatrixStack.pop();
    }

    AnimatedHeader.prototype.setMatrixUniforms = function() { //enviem totes les uniforms del programa actual
        this.gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, this.pMatrix);
        this.gl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, this.mvMatrix);
        var normalMatrix = mat3.create();
        mat3.normalFromMat4(normalMatrix, this.mvMatrix);
        this.gl.uniformMatrix3fv(this.shaderProgram.nMatrixUniform, false, normalMatrix);
		this.gl.uniform3fv(this.shaderProgram.colorUniform,this.drawColor)
    }

    AnimatedHeader.prototype.update = function() {
        var deltaTime = this.timer.tick();

		AnimatedHeader.handleMouse(deltaTime);
		
		this.rot += this.rotSpeed*deltaTime;
		this.rotSpeed = this.rotSpeed*((3.0 - deltaTime)/3.0); //Lerp into 0
    }

    AnimatedHeader.prototype.draw = function() {
		this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight);
		this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
		
		//resetejar la ModelView
		mat4.identity(this.mvMatrix);
		
		//camera
		mat4.translate(this.mvMatrix, this.mvMatrix,[0,0,-10]);
		
		//cube
		this.mvPushMatrix();
			mat4.rotate(this.mvMatrix, this.mvMatrix, degToRad(this.rot), [0, 1, 0]);
			//Position rotation of cube to look nice
			mat4.rotate(this.mvMatrix, this.mvMatrix, degToRad(90), [1, 0, 0]);
			mat4.rotate(this.mvMatrix, this.mvMatrix, degToRad(-11.25), [0, 1, 0]);
			mat4.rotate(this.mvMatrix, this.mvMatrix, degToRad(45), [0, 1, 0]);
			mat4.rotate(this.mvMatrix, this.mvMatrix, degToRad(45), [1, 0, 0]);
			mat4.scale(this.mvMatrix, this.mvMatrix, [5,5,5]);
			this.setMatrixUniforms();
			this.cube.draw(this.gl,this.shaderProgram);
		this.mvPopMatrix();

	}

    var AnimatedHeader;
	var assetManager;

    function loop() {
        requestAnimFrame(loop);
        AnimatedHeader.update();
        AnimatedHeader.draw();
    }

    function initHeader() {
    	var canvas = document.getElementById("canvas");
		canvas.width = document.body.clientWidth - 20; // Hax20r
        canvas.height = document.body.clientWidth/5;
		
		assetManager = new AssetManager();
		
		assetManager.queueDownload("fon.png");
		
		assetManager.downloadAll(function() {
			AnimatedHeader = new AnimatedHeader(canvas);
			loop();
		});
    }

</script>
</head>

<!-- Some credit to Towerthousand for his WebGL github repo at https://github.com/Towerthousand/WebGL-Test/ which helped <3 -->
<body  bgcolor="#D2FAF7" onload="initHeader();">
	<canvas id="canvas" width="256" height="256"
		style=" padding-left: 0;
				padding-right: 0;
				margin-left: auto;
				margin-right: auto;
				display: block;">
	</canvas>
    <center><br> Work in progress </br></center>
</body>
</html>
